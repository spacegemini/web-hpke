/**
 * Bundled by jsDelivr using Rollup v2.79.2 and Terser v5.39.0.
 * Original file: /npm/@hpke/dhkem-x25519@1.6.4/esm/mod.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
import{montgomery as e,mod as t,pow2 as r,HkdfSha256Native as i,hmac as n,sha256 as a,SerializeError as f,DeserializeError as c,XCryptoKey as s,KEM_USAGES as o,NotSupportedError as y,EMPTY as h,LABEL_DKP_PRK as u,LABEL_SK as w,DeriveKeyPairError as l,base64UrlToBytes as d,Dhkem as b,KemId as v}from"./hpke_common.js";const p=BigInt(1),P=BigInt(2),_=BigInt(3),m=BigInt(5),k=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed");function K(e){return e[0]&=248,e[31]&=127,e[31]|=64,e}const g=(()=>{const i=k;return e({P:i,type:"x25519",powPminus2:e=>{const{pow_p_5_8:n,b2:a}=function(e){const t=BigInt(10),i=BigInt(20),n=BigInt(40),a=BigInt(80),f=k,c=e*e%f*e%f,s=r(c,P,f)*c%f,o=r(s,p,f)*e%f,y=r(o,m,f)*o%f,h=r(y,t,f)*y%f,u=r(h,i,f)*h%f,w=r(u,n,f)*u%f,l=r(w,a,f)*w%f,d=r(l,a,f)*w%f,b=r(d,t,f)*y%f;return{pow_p_5_8:r(b,P,f)*e%f,b2:c}}(e);return t(r(n,_,i)*a,i)},adjustScalarBytes:K})})();class S extends i{async extract(e,t){if(await this._setup(),0===e.byteLength&&(e=new ArrayBuffer(this.hashSize)),e.byteLength!==this.hashSize)return n(a,new Uint8Array(e),new Uint8Array(t)).buffer;const r=await this._api.importKey("raw",e,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",r,t)}}const I="X25519";class z{constructor(e){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=e,this._nPk=32,this._nSk=32}async serializePublicKey(e){try{return await this._serializePublicKey(e)}catch(e){throw new f(e)}}async deserializePublicKey(e){try{return await this._importRawKey(e,!0)}catch(e){throw new c(e)}}async serializePrivateKey(e){try{return await this._serializePrivateKey(e)}catch(e){throw new f(e)}}async deserializePrivateKey(e){try{return await this._importRawKey(e,!1)}catch(e){throw new c(e)}}async importKey(e,t,r){try{if("raw"===e)return await this._importRawKey(t,r);if(t instanceof ArrayBuffer)throw new Error("Invalid jwk key format");return await this._importJWK(t,r)}catch(e){throw new c(e)}}async generateKeyPair(){try{const e=await g.utils.randomSecretKey(),t=new s(I,e,"private",o);return{publicKey:await this.derivePublicKey(t),privateKey:t}}catch(e){throw new y(e)}}async deriveKeyPair(e){try{const t=await this._hkdf.labeledExtract(h.buffer,u,new Uint8Array(e)),r=await this._hkdf.labeledExpand(t,w,h,this._nSk),i=new s(I,new Uint8Array(r),"private",o);return{privateKey:i,publicKey:await this.derivePublicKey(i)}}catch(e){throw new l(e)}}async derivePublicKey(e){try{return await this._derivePublicKey(e)}catch(e){throw new c(e)}}async dh(e,t){try{return await this._dh(e,t)}catch(e){throw new f(e)}}async derive(e,t){try{return await this._derive(e,t)}catch(e){throw new f(e)}}_serializePublicKey(e){return new Promise((t=>{t(e.key.buffer)}))}_serializePrivateKey(e){return new Promise((t=>{t(e.key.buffer)}))}_importRawKey(e,t){return new Promise(((r,i)=>{t&&e.byteLength!==this._nPk&&i(new Error("Invalid length of the key")),t||e.byteLength===this._nSk||i(new Error("Invalid length of the key")),r(new s(I,new Uint8Array(e),t?"public":"private",t?[]:o))}))}_importJWK(e,t){return new Promise(((r,i)=>{void 0!==e.kty&&"OKP"===e.kty||i(new Error(`Invalid kty: ${e.kty}`)),void 0!==e.crv&&"X25519"===e.crv||i(new Error(`Invalid crv: ${e.crv}`)),t?(void 0!==e.d&&i(new Error("Invalid key: `d` should not be set")),void 0===e.x&&i(new Error("Invalid key: `x` not found")),r(new s(I,d(e.x),"public"))):("string"!=typeof e.d&&i(new Error("Invalid key: `d` not found")),r(new s(I,d(e.d),"private",o)))}))}_derivePublicKey(e){return new Promise(((t,r)=>{try{const r=g.getPublicKey(e.key);t(new s(I,r,"public"))}catch(e){r(e)}}))}_dh(e,t){return new Promise(((r,i)=>{try{r(g.getSharedSecret(e.key,t.key).buffer)}catch(e){i(e)}}))}_derive(e,t){return new Promise(((r,i)=>{try{r(g.getSharedSecret(e,t))}catch(e){i(e)}}))}}class x extends b{constructor(){const e=new S;super(v.DhkemX25519HkdfSha256,new z(e),e),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:v.DhkemX25519HkdfSha256}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:32})}}export{x as DhkemX25519HkdfSha256,S as HkdfSha256,z as X25519};export default null;
//# sourceMappingURL=/sm/7729e48dc5f1f6fc7d88e426fe1f27b8a242ef21d057bd4b82949e2df1a20ef6.map